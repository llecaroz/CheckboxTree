<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>    <title>CheckboxTree: A custom tree component with checkable nodes</title>    <style type="css">      body, td, pre {          font-size: x-small;          font-family: Verdana, Arial, Helvetica, sans-serif;          color: #000;          font-size: small;          font-family: Verdana, Arial, Helvetica, sans-serif;          color: #000;      }      code, pre {          margin: 0;          padding: 0;      }</style>  </head>  <!-- ABSTRACT: CheckboxTree is an open source, Swing-based tree component with acheckbox in each of its nodes, similar to those commonly found in installersbut missing from the Swing GUI toolkit. In this article creators LorenzoBigagli and Enrico Boldrini introduce CheckboxTree and demonstrate itsstandout features, namely four configurable check propagation styles, grayedcheckboxes, and a customizable renderer that allows you to display your favouritecheckbox control in your tree layouts. The article includes the sourcecode for CheckboxTree, which you may use or extend for your Swing GUIdevelopment projects.TOC_BLURB: Application GUIs commonly feature checkbox-enabled tree layouts,but you won't find such a component in the Swing toolkit. You will find onehere though - open source, extensible, and ready for use in  your Swing development projects.KEYWORDS: CheckboxTree, JTree, Swing GUI, tree layout, checkbox, custom, customizable, configurable, component, check propagation, grayed, graying, custom renderer, rendering, selection, tristate, quadristate, LorenzoBigagli, Enrico Boldrini--><body><h1>Swing-based tree layouts with CheckboxTree</h1> <!-- eb/lb changed the subtitle, we like this more --><h2>A configurable tree component with checkable nodes</h2><p>Installation GUIs and application preference windows often featurecheckbox-enabled tree components, but you won't find such a component in theSwing GUI toolkit. Most developers either end up extending the Swing<code>JTree</code> ad-hoc or using one of the <a href="#resources">treeextensions</a> available. We actually tried several of these components for arecent project but found that none of them had quite the features, simplicity,or flexibility we needed.</p><!--ao: revised your explanation of grayed checkboxes below.--><p>Some components were part of an overly complicated widget library orrequired extending specific classes that disrupted our class hierarchy design.Some were not open source or relied on libraries that were not open source.Some had native dependencies. Most important, we needed a component that wouldsupport several checkbox propagation styles in a tree layout. We also wanted grayable checkboxes to indicate if descendants of a given node were in the opposite checking state from that node. So, like many developers before us,we created our <code>CheckboxTree</code> component from scratch.</p><!--ao: added placeholders for the applet.--><p><code>CheckboxTree</code> is a Swing <code>JTree</code> component with acheckbox in each of its nodes, as shown in Figure 1 (click the image for alive demonstration).</p><a name="figure1" href="http://www.javaworld.com/checkboxtreeapplet.html"> <img src="http://www.javaworld.com/javaworld/jw-09-2007/images/checkboxtree.jpg" height="295" width="211" alt="CheckboxTree is a Swing JTree with a checkbox in each of its nodes."> </a><h4>Figure 1. CheckboxTree: Checked, selected, and grayed paths are visible</h4><p>In this article weintroduce <code>CheckboxTree</code> and explain its relationshipto the Swing <code>JTree</code> classes. We also discuss its architecture andprovide implementation details. Finally, we highlight some of the currentlimitations of <code>CheckboxTree</code> and note improvements that could bemade to it in the future. <code>CheckboxTree</code> is available under the GPL license, so you are free to use it in your Swing development projects.</p><h2>Background: JTree concepts and terminology</h2><p>Before we begin describing <code>CheckboxTree</code> in detail, it might behelpful to quickly recall some Swing <code>JTree</code> concepts andterminology:</p><ul><li><b>JTree</b>, as described in the <a href="#resources">Swingdocumentation</a>, is a "control that displays a set of hierarchical data asan outline."</li><li>A <b>node</b> is the basic unit of data displayed by a <code>JTree</code>.A specific node can be identified either by a <code>TreePath</code> or by itsdisplay row.</li><li><b>TreePath</b> is an object that contains a <code>JTree</code> node andall its ancestors.</li><li><b>TreeModel</b> is an object that manages the <code>JTree</code> datamodel based on the well-known MVC design pattern.</li><li><b>TreeSelectionModel</b> is an object that manages user selections in a<code>JTree</code>, typically rendered by highlighting selected nodes.</li><li><b>TreeCellRenderer</b> is used to style <code>JTree</code> nodesaccording to their content and status.</li></ul><h2>Using CheckboxTree</h2><p> A key feature of <code>CheckboxTree</code> is that it does not require youto use tree nodes that implement a specific "checkable-node" interface (e.g., aninterface with a method <code>isChecked</code>). You can continue to work withyour preferred tree model, such as the default <code>TreeModel</code> or acustom one, which makes it easier to integrate <code>CheckboxTree</code> intoyour existing code. </p><p>You can use <code>CheckboxTree</code> by invoking one of the providedconstructors, which are modeled after the standard <code>JTree</code> ones.The sample below shows how you would construct a <code>CheckboxTree</code> with a default <code>TreeModel</code>.</p><pre><code>CheckboxTree checkboxTree = new CheckboxTree(); </code> </pre><p>Here is how you would construct a <code>CheckboxTree</code> from an existing <code>TreeNode</code>:</p><pre><code>TreeNode yourRoot = new DefaultMutableTreeNode("foo"); CheckboxTree checkboxTree = new CheckboxTree(yourRoot); </code></pre><p>Here is  how you would construct a <code>CheckboxTree</code> from an existing <code>TreeModel</code>:</p><pre><code>Model yourTreeModel = new DefaultTreeModel(new DefaultMutableTreeNode("foo"));CheckboxTree checkboxTree = new CheckboxTree(yourTreeModel); </code> </pre><p>You could also set the data model at a later time, as shown here:</p><pre><code>Model yourNewTreeModel = new DefaultTreeModel(new DefaultMutableTreeNode("bar"));checkboxTree.setModel(yourNewTreeModel);</code></pre><p>Once constructed, your <code>CheckboxTree</code> is ready to listen foruser input and respond.</p><!--ao: I think the extended definition below is good enough to explain your concept of "checking."--><h2>State management and event handling</h2><p>All <code>CheckboxTree</code> nodes include a checkbox. If the checkbox isenabled, the user can check it to indicate his/her selection. A <i>checkednode</i> is a tree node whose checkbox has been checked. In the same way a<i>checked path</i> is a <code>TreePath</code> whose node has been checked. In <code>CheckboxTree</code> we use the term <i>checking</i> to indicate the set of paths that are checked at a given point in time, just as in <code>JTtree</code>the term <i>selection</i> indicates the set of paths that are selected. </p><p>Going back to <a href="#figure1">Figure 1</a> and playing with the applet, you will notice that thecheck events on a node may propagate to its descendants and/or ancestors,according to the check propagation style selected. We'll discuss checkpropagation below. You will also notice that somecheckboxes have a grayed background: that means that the checkbox of at leastone descendant node is in the opposite state from that node. On the otherhand, if a checkbox has a white background, you can be sure that thecheckboxes of all its descendants are in the same state.<code>CheckboxTree</code> uses a <code>TreeCheckingModel</code> to maintainthe checking and background consistency. This is similar to how a<code>JTree</code> maintains selection consistency by means of a<code>TreeSelectionModel</code>.</p><h3>Some useful commands</h3><p>Here is how you can retrieve the list of checked paths:</p><pre> <code>TreePath[] tp = checkboxTree.getCheckingPaths(); </code> </pre><p>If you are only interested in retreiving the <i>roots</i> of your checked subtrees, you can use the following:</p><pre> <code> TreePath[] tp = checkboxTree.getCheckingRoots(); </code> </pre><p>Here is how you would register a <code>TreeCheckingListener</code> to listen for changes to the checking state of your <code>CheckboxTree</code>.</p><pre><code>checkboxTree.addTreeCheckingListener(new TreeCheckingListener() {     public void valueChanged(TreeCheckingEvent e) {         System.out.println("Checked paths changed: user clicked on "             + (e.getLeadingPath().getLastPathComponent()));     }});</code></pre><h2>Customizing CheckboxTree</h2><p>So far you have seen the basic usage of a <code>CheckboxTree</code>. Inthis section we'll introduce two ways to customize this component. First,we'll show you how to configure the component's check propagation style. Then, we'll show you how to write a customized<code>CheckboxTreeCellRenderer</code>, which will allow you to display your favourite checkbox control in a tree layout.</p><h3>Configurable checking modes</h3><p>In <code>CheckboxTree</code>, <i>checking mode</i> describes the way a checkevent is propagated to other checkboxes. We have implemented four checkingmodes for the component, which can be set as shown in Listing 1 (note that youcan also add new modes by implementing your own <code>TreeCheckingMode</code>class.)</p><h4>Listing 1. Checking modes in CheckboxTree</h4><pre><code>           checkboxTree.getCheckingModel().setCheckingMode(TreeCheckingModel.CheckingMode.SIMPLE);              checkboxTree.getCheckingModel().setCheckingMode(TreeCheckingModel.CheckingMode.PROPAGATE);              checkboxTree.getCheckingModel().setCheckingMode(TreeCheckingModel.CheckingMode.PROPAGATE_PRESERVING_CHECK);              CheckboxTree.getCheckingModel().setCheckingMode(TreeCheckingModel.CheckingMode.PROPAGATE_PRESERVING_UNCHECK);</code></pre><p>Each of the above styles uses different rules to propagate a check event.The checking model takes care of the background accordingly. The modesare as follows:</p><ul><li><b>Simple</b> toggles the just-clicked checkbox only.</li><li><b>Propagate</b> toggles the just-clicked checkbox andpropagates the change down. In other words, if the clicked checkbox is checked all thedescendants will be checked; otherwise all the descendants will beunchecked.</li><li><b>Propagate preserving check</b> propagates the change not only todescendants but also to ancestors. With regard to <i>descendants</i> this modebehaves exactly like the Propagate mode. With regard to <i>ancestors</i> itchecks/unchecks them as needed so that a node is checked if and onlyif all of its children are checked.</li><li><b>Propagate preserving uncheck</b> propagates the change not only todescendants but also to ancestors. With regard to <i>descendants</i> this modebehaves exactly like the Propagate mode. With regard to <i>ancestors</i> itchecks/unchecks them as needed so that a node is unchecked if and onlyif all of its children are unchecked.</li></ul><h3>Checkbox rendering</h3><p><code>CheckboxTree</code>'s <code>DefaultCheckboxTreeCellRenderer</code>renders a tree node using a textual label and a special checkbox that supportsgrayed background rendering. You can customize the checkboxrendering by implementing the <code>CheckboxTreeCellRenderer</code>interface.</p><p>This interface extends the Swing <code>TreeCellRenderer</code> interface intwo ways: First, it re-declares the <code>getTreeCellRendererComponent</code>,just as a reminder for the implementor to properly display the checking/grayedstatus of the node. We would have preferred to enforce this in some otherway, such as by adding a method parameter, but that would have requiredchanges to the Swing classes, which we considered impractical.</p><p>Second, it declares the method <code>isOnHotspot(int x, int y)</code>,which returns whether the specified relative coordinates insist on theintended checkbox control. This information may be used by a mouse listener todetermine whether to toggle a node or not. In fact, it allows<code>CheckboxTree</code> to accommodate an arbitrary<code>CheckboxTreeCellRenderer</code>.</p><h3>Example: a custom CheckboxTreeCellRenderer</h3><p>Figure 2 shows a <code>CheckboxTree</code> that has been customized todisplay radio buttons rather than checkboxes. Other custom renderers could usetheir own custom checkboxes rather than <code>CheckboxTree</code>'squadristate checkbox. It is possible to customize a<code>CheckboxTreeCellRenderer</code> in many different ways. For instance, inone project we put in the <code>CheckboxTree</code> objects belonging todifferent classes. A custom <code>CheckboxTreeCellRenderer</code> then showed adifferent icon as needed.</p><a name="figure2"><img src="http://www.javaworld.com/javaworld/jw-09-2007/images/radiobuttontree.jpg" width="165" height="230" alt="Customized CheckboxTreeCellRenderer"></a><h4>Figure 2. A customized CheckboxTreeCellRenderer</h4><p>Listing 2 shows the <code>RadioButtonTree</code> implementation. You could use this code as a starting point to write a new customized renderer.</p><h4>Listing 2. The RadioButtonTree</h4><pre><code>public class RadioButtonTreeCellRenderer implements CheckboxTreeCellRenderer {  JRadioButton button = new JRadioButton();  JPanel panel = new JPanel();  JLabel label = new JLabel();  public boolean isOnHotspot(int x, int y) {    return (button.getBounds().contains(x, y));  }  public RadioButtonTreeCellRenderer() {    label.setFocusable(true);    label.setOpaque(true);    panel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));    panel.add(button);    panel.add(label);                 button.setBackground(UIManager.getColor("Tree.textBackground"));    panel.setBackground(UIManager.getColor("Tree.textBackground"));  }  public Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row,boolean hasFocus) {    label.setText(value.toString());    if (selected)      label.setBackground(UIManager.getColor("Tree.selectionBackground"));    else      label.setBackground(UIManager.getColor("Tree.textBackground"));    TreeCheckingModel checkingModel = ((CheckboxTree) tree).getCheckingModel();    TreePath path = tree.getPathForRow(row);    boolean enabled = checkingModel.isPathEnabled(path);    boolean checked = checkingModel.isPathChecked(path);    boolean grayed = checkingModel.isPathGreyed(path);    button.setEnabled(enabled);    if (grayed) {      label.setForeground(Color.lightGray);    } else {      label.setForeground(Color.black);    }    button.setSelected(checked);    return panel;  }  public static void main(String[] args) {    CheckboxTree tree = new CheckboxTree();    tree.getCheckingModel().setCheckingMode(CheckingMode.SIMPLE);    tree.setCellRenderer(new RadioButtonTreeCellRenderer());    JFrame frame = new JFrame("RadioButton tree");    frame.add(tree);    tree.expandAll();    frame.pack();    frame.setVisible(true);  }}</code></pre><h2>Inside CheckboxTree</h2><p><code>CheckboxTree</code> extends the Swing <code>JTree</code> withfeatures for visualizing and managing checkboxes and checking events. Wecreated a specialized <code>TreeCheckingModel</code> class to manage checkingevents in <code>CheckboxTree</code>. Our <code>TreeCheckingModel</code> has anAPI similar to <code>TreeSelectionModel</code>, which is the class thatmanages selection events for Swing GUI components. The<code>TreeCheckingModel</code> API is easy to use for any developer familiarwith the Swing GUI toolkit. The similarity between our<code>TreeCheckingModel</code> and the Swing <code>TreeSelectionModel</code>extends to the class hierarchy and inheritance structure, as you can see inFigure 3.</p><a name="figure3" href="http://www.javaworld.com/javaworld/jw-09-2007/images/diaright.jpg"><img src="http://www.javaworld.com/javaworld/jw-09-2007/images/diaright-thumb.jpg" height="139" width="350" alt="TreeCheckingModel and TreeSelectionModel compared"></a><h4>Figure 3. TreeSelectionModel (yellow classes) and TreeCheckingModel (green classes) compared; click for a larger image</h4><p>You will note that the <code>JTree</code> class uses a<code>TreeModel</code>, a <code>TreeCellRenderer</code>, and a<code>TreeSelectionModel</code> to carry out its functions. The<code>CheckboxTree</code> component extends <code>JTree</code> to also use the<code>TreeCheckingModel</code> API. Moreover, <code>CheckboxTree</code>requires an implementation of <code>CheckboxTreeCellRenderer</code>, which isa <code>TreeCellRenderer</code> that displays a checkbox or similar componentsinside each tree node (we provide a<code>DefaultCheckboxTreeCellRenderer</code> with a<code>QuadristateCheckbox</code>.)</p><p>We needed a <code>TreeCellRenderer</code> capable of displaying a checkboxin four states: checked, unchecked, gray checked, and gray unchecked. For thiswe implemented a <code>QuadristateCheckbox</code>, which is ableto support a GUI's given look and feel and display the four states,managed by a <code>QuadristateButtonModel</code>. The classhierarchy for the <code>QuadristateButtonModel</code> is shown in Figure 4.The <code>QuadristateCheckbox</code> is actually a hack that allows us todisplay two new states within a normal <code>JCheckbox</code>, based on the approach used in <a href="#resources">TristateCheckBox</a>.</p><a name="figure4" href="http://www.javaworld.com/javaworld/jw-09-2007/images/dialeft.jpg"> <img src="http://www.javaworld.com/javaworld/jw-09-2007/images/dialeft-thumb.jpg" height="160" width="350" alt="QuadritsateCheckbox class diagram"> </a><h4>Figure 4. Class diagram of the QuadristateCheckbox</h4><h2>The future of CheckboxTree</h2> <p>We plan to fix some known limitations to <code>CheckboxTree</code> infuture releases. The main limitation has to do with the component'sperformance when propagating checks in very big data models. For example, if a user clicks on a node with many descendants, the GUI freezesfor the time required to insert all the affected subpaths in therelevant <code>TreeCheckingModel</code> data structures. We plan to fix thisby optimizing the memorization of the descendants checking state. Only the ancestors will need to be stored in an appropriate set,which will greatly reduce execution time.</p><p>Another limitation concerns the rendering of gray states in <code>CheckboxTree</code>checkboxes, which is done by setting the <code>armed</code> property to <i>true</i> in the model. The price of thisis that we can't show rollover events on the checkboxes. A betterimplementation of the <code>QuadristateCheckbox</code> will allow us to managerollover events and display them appropriately.</p><!--ao: minor revision below.--><p>Another rendering problem occurs when the checkbox position inside therenderer is relative to the path to be displayed. Swing design calls for aunique renderer object that is used by every row. Thus we can'trely on it to know if the click has be made inside a checkbox, when differentrows have checkboxes at different positions.</p><p>If you have ideas about fixing any of these problems, or ideas for new features, please feel free to contribute!</p><h2>In conclusion</h2><p>In this article we have introduced <code>CheckboxTree</code>, a handy newwidget for your Swing GUI development. While other <code>JTree</code>components have been extended to include checkboxes, we believe<code>CheckboxTree</code> offers unique features and flexibility. We'veexplained how <code>CheckboxTree</code> extends from the Swing<code>JTree</code> widget, introduced its unique, configurable propagationmodel and grayed checkboxes, and highlighted some of the implementation detailsthat could make it easier for you to use and extend<code>CheckboxTree</code>.</p><p>See the <a href="#resources">Resources section</a> to learn moreabout the Swing GUI toolkit, Swing development, and other components thatextend the functionality of the Swing <code>JTree</code>. Join thediscussion that starts at the bottom of this page to let us know aboutyour experiences with Swing <code>JTree</code> components -- especially<code>CheckboxTree</code>!</p><h2>About the authors</h2> <p><a href="mailto:bigagli@imaa.cnr.it">LorenzoBigagli</a> is a researcher at the Italian National Research Council and theUniversity of Florence, currently taking a PhD on advanced technologies forSpatial Data Infrastructures. He has loved Java for more than 10 years (andcounting), particularly for its support for concurrent programming andnetworking.</p><p><a href="mailto:boldrini@imaa.cnr.it">Enrico Boldrini</a> is a computerscientist currently taking a MSc at the University of Florence. He also worksfor the Italian National Research Council (in the Earth Space InformationTechnologies Laboratory) developing Java applications for Geomatics.</p><a name="resources"><h2>Resources</h2><ul><li><a href="http://zeus.pin.unifi.it/projectsSites/lablib-checkboxtree">DownloadCheckboxTree</a> and start using it in your Swing GUIs.</li><li>"<a href="http://www.javaworld.com/javaworld/jw-10-1998/jw-10-jtree.html">Capturehierarchical structures with Swing's JTree</a>" (Tomer Meshorer, JavaWorld,October 1998) introduces the Swing toolkit's standard tree component. </li><li>"<a href="http://www.javaworld.com/javatips/jw-javatip97.html">Java Tip97: Add drag and drop to your JTrees</a>" (Rob Kenworthy, JavaWorld, June2000) is a step-by-step guide to hacking <code>JTree</code> for drag-and-dropusability.</li><li>"<a href="http://www.javaworld.com/javaworld/javatips/jw-javatip114.html">Java Tip114: Add ghosted draggable images to your JTrees</a>" (Andrew Armstrong,JavaWorld, August 2001) builds on Java Tip 97 with instructions for replacingcheckboxes or radio buttons with images (such as folders), then using a fadeeffect to represent the node in transit.</li><li>Learn more about the <a href="http://www.javaspecialists.eu/archive/Issue082.html">TristateCheckBox</a>, developed by Dr. Heinz M. Kabutz (<em>Java Specialists' Newsletter</em>,issue 082, December 2003).</li><li><a href="https://jide-oss.dev.java.net">Jide CheckBoxTree</a> is atristate checkbox tree with a default check propagation style, recentlyreleased as open source (Java Net, April 2007).</li><li> <a href="http://java.chinaitlab.com/Swing/714937.html">ChinaITLabcheckboxtree</a> is a tristate checkbox tree whose nodes must be<code>SelectableTreeNode</code>s.</li><li><a href="http://www.jroller.com/santhosh/date/20050610 ">JTree withcheckboxes</a> (Santhosh Kumar, jRoller, June 2005) is another example of aSwing-based <code>JTree</code> component with checkboxes.</li><li><a href="http://www.java2s.com/Code/Java/Swing-JFC/CheckBoxNodeTreeSample.htm">Checkbox node tree</a> is one of many Swing-basedTree widgets from John Zukowski's <i>Definitive Guide to Swing for Java 2,Second Edition</i> (Apress, November 2000).</li><li>See the question "<a href="http://www.javaworld.com/javaforums/showflat.php?Cat=2&amp;Number=19766">How to customize a JTree with checkboxes?</a>" (JavaWorld developer forums,July 2005) for even more checkbox options.</li><li>Read the <a href="http://java.sun.com/j2se/1.5.0/docs/api/javax/swing/JTree.html">SwingJTree documentation</a> to learn more about Swing-based tree components.</li><li>Visit the JavaWorld the <a href="http://www.javaworld.com/channel_content/jw-core-index.html">JavaStandard Edition research center</a> for more articles about Swing programmingand component development.</li><li>Also check out the JavaWorld <a href="http://www.javaworld.com/javaforums/ubbthreads.php?">developerforums</a> for discussions and Q&amp;A related to Swing programming and the<code>JTree</code> component.</li>    </ul>  </body></html>